//
//  MeshGenerator.swift
//  ColorWheel
//
//  Created by Gaetano Matonti on 15/06/24.
//  Copyright Â© 2024 Gaetano Matonti. All rights reserved.
//

import Foundation
import SwiftUI
import Vectors

/// An object that generates the grid for a mesh gradient.
struct MeshGenerator {

  /// A type that represents a row index.
  typealias Row = Int

  /// A type that represents a column index.
  typealias Column = Int

  /// The closure that creates a vertex from row, and column indices, and a `GridHelper` object.
  typealias VertexProvider = (Row, Column, GridHelper) -> MeshVertex

  // MARK: - Stored Properties

  /// The columns of the grid.
  let columns: Row

  /// The rows of the grid.
  let rows: Column

  /// The closure that creates a vertex from row, and column indices, and a `GridHelper` object.
  private var vertexProvider: VertexProvider

  // MARK: - Computed Properties

  /// The vertices generated by the object.
  var vertices: [[MeshVertex]] {
    generateVertices()
  }

  /// The `GridHelper` object to help with grid computations.
  private var helper: GridHelper {
    GridHelper(columns: columns, rows: rows)
  }

  // MARK: - Init

  init(columns: Int, rows: Int, vertexProvider: @escaping VertexProvider) {
    precondition(columns > 1 && rows > 1, "The number of columns and rows must be greater than 1.")

    self.columns = columns
    self.rows = rows
    self.vertexProvider = vertexProvider
  }

  // MARK: - Functions

  /// Generates the vertices of the mesh.
  private func generateVertices() -> [[MeshVertex]] {
    var vertices: [[MeshVertex]] = Array(repeating: [], count: rows)

    for row in 0..<rows {
      for column in 0..<columns {
        let vertex = vertexProvider(row, column, helper)
        vertex.location = helper.location(row, column)
        vertices[row].insert(vertex, at: column)
      }
    }

    return vertices
  }
}

extension MeshGenerator {
  /// A preset grid where the position of the vertices is associated to a hue.
  static func rainbow(columns: Int, rows: Int) -> MeshGenerator {
    MeshGenerator(columns: columns, rows: rows) { row, column, helper in
      let center = CGPoint(x: 0.5, y: 0.5)
      let position = helper.position(for: row, and: column)

      /// The offset position, so that the it falls in the range [-1, 1]
      var offsetPosition = position - center
      offsetPosition = offsetPosition * 2.0
      offsetPosition = offsetPosition.limit(1)

      let hue = atan2(offsetPosition.y, offsetPosition.x)
      let saturation = offsetPosition.magnitude

      let color = HSB(hue: .radians(hue), saturation: saturation, brightness: 1)
      return MeshVertex(position: position, color: color)
    }
  }

  static var aurora: MeshGenerator {
    MeshGenerator(columns: 5, rows: 5) { row, column, helper in
      let baseColor = HSB(hue: .degrees(180), saturation: 1.0, brightness: 1.0)
      let distance = Angle(degrees: 5.0 * (CGFloat(row) + 1.0))
      let colors = ColorScheme.analogous(from: baseColor, distance: distance).hsbColors

      if case .center = helper.location(row, column) {
        return MeshVertex(
          position: helper.position(for: row, and: column),
          color: colors[column - 1]
        )
      } else {
        return MeshVertex(
          position: helper.position(for: row, and: column),
          color: HSB(hue: .degrees(180), saturation: 0.0, brightness: 0.0)
        )
      }
    }
  }

  static func custom(columns: Int, rows: Int) -> MeshGenerator {
    MeshGenerator(columns: columns, rows: rows) { row, column, helper in
      return MeshVertex(
        position: helper.position(for: row, and: column),
        color: HSB(hue: .zero, saturation: 0.0, brightness: 0.0)
      )
    }
  }
}

struct MeshPreset: Identifiable {
  enum Identifier: Hashable, Equatable {
    case rainbow
    case aurora
    case custom(columns: Int, rows: Int)
  }

  let id: Identifier

  let label: String

  let generator: MeshGenerator
}

extension MeshPreset: Hashable {
  func hash(into hasher: inout Hasher) {
    hasher.combine(id)
  }
}

extension MeshPreset {
  static func ==(lhs: MeshPreset, rhs: MeshPreset) -> Bool {
    lhs.id == rhs.id
  }
}

extension MeshPreset {
  static var rainbow: MeshPreset {
    MeshPreset(id: .rainbow, label: "Rainbow", generator: .rainbow(columns: 5, rows: 5))
  }

  static var aurora: MeshPreset {
    MeshPreset(id: .aurora, label: "Aurora", generator: .aurora)
  }

  static var custom: MeshPreset {
    .custom(columns: 3, rows: 3)
  }

  static func custom(columns: Int, rows: Int) -> MeshPreset {
    MeshPreset(
      id: .custom(columns: columns, rows: rows),
      label: "Custom",
      generator: .custom(columns: columns, rows: rows)
    )
  }

  static var allCases: [MeshPreset] {
    [
      .rainbow,
      .aurora,
      .custom
    ]
  }
}
